### Type Vector

*В этой задаче неободимо реализовать вектор, который хранит... типы. То есть организовать хранение последовательности
типов с реализованными операциями доступа к элементам, изменения последовательности, изменения типов, сортировки...
И все это на этапе компиляции!*

##### Первый уровень (обязательная часть)

Организуем хранение типов с помощью шаблонной структуры `TypeVector`. Эта структура может быть параметризована
произвольным количеством типов (шаблон с переменным числом аргументов), которые и будут являться "элементами" вектора.
Так как нас интересуют не значения, а только типы, эта структура может быть пустой (хотя при необходимости можете
добавить какую-нибудь информацию в ее тело).

С помощью механизма шаблонной специализации реализуйте следующие шаблонные структуры, задающие операции над вектором
типов:
* `Size<TV>`, которая в поле `value` хранит число элементов в векторе `TV`;
* `Empty<TV>`, которая в поле `value` хранит флаг, пуст ли вектор `TV`;
* `Front`/`Back<TV>`, которые содержат тип-член `type` с первым/последним типом в векторе `TV` (если вектор пуст, то
`type` быть не должно);
* `At<TV, Idx>`, которая содержит тип-член `type` с элементом, стоящим на позиции `Idx` (0-индексация) в векторе `TV`
(если вектор пуст, то `type` быть не должно);
* `Contains<TV, T>`, которая в поле `value` хранит флаг, содержит ли вектор `TV` элемент `T`;
* `Count<TV, T>`, которая в поле `value` хранит количество элементов `T` в векторе `TV`;
* `PushFront/PushBack<TV, T>`, которая содержит тип-член `type` с вектором, полученным в результате добавления типа `T`
в начало/конец вектора `TV`;
* `PopFront/PopBack<TV>`, которая содержит тип-член `type` с вектором, полученным в результате удаления элемента из
начала/конца вектора `TV` (если вектор пуст, то `type` быть не должно);
* `Concatenate<TV1, TV2>`, которая содержит тип-член `type` с вектором, полученным в результате конкатенации векторов
`TV1` и `TV2`;

Также для всех структур с `value` определите шаблонную переменную `k***V` с соответствующим значением, а для структур с
`type` - псевдоним `***T` с соответствующим типом, где `***` - имя структуры.

Примеры применения ищите в файле с тестами.

##### Второй уровень (дополнительная часть 1)

Реализуйте простейшие алгоритмы (в виде шаблонных структур) для работы с вектором типов, а именно:

* `Insert<TV, Idx, T>`, которая содержит тип-член `type` с вектором, полученным в результате вставки типа `T` в позицию `Idx` (0-индексация) вектора `TV` (если `Idx` совпадает с размером вектора, то вставка осуществляется в конец вектора,
если `Idx` выходит за границы массива, то `type` быть не должно);
* `EraseFirst<TV, T>`, которая содержит тип-член `type` с вектором, полученным в результате удаления первого с начала
типа `T` из вектора `TV`;
* `EraseAll<TV, T>`, которая содержит тип-член `type` с вектором, полученным в результате удаления всех типов `T` из
вектора `TV`;
* `Reverse<TV>`, которая содержит тип-член `type` с вектором, полученным в результате разворота вектора `TV`;
* `Unique<T>`, которая сожержит тип-член `type` с вектором, содержащим только уникальные типы из `TV` (с сохранением
относительного порядка).
* `Transform<TV, F>`, которая содержит тип-член `type` с вектором, полученным в результате применения шаблона `F` к
каждому типу из `TV` (`F<T>` задает обновленный тип, где `T` - старый элемент вектора).
* `AllOf<TV, Predicate>`, которая в поле `value` хранит флаг, верно ли, что `Predicate<T>::value` истина для всех `T` из
 `TV`;
* `AnyOf<TV, Predicate>`, которая в поле `value` хранит флаг, верно ли, что `Predicate<T>::value` истина для
какого-нибудь `T` из `TV`;

Также для всех структур с `value` определите шаблонную переменную `k***V` с соответствующим значением, а для структур с
`type` - псевдоним `***T` с соответствующим типом, где `***` - имя структуры.

Примеры применения ищите в файле с тестами.

# Третий уровень (дополнительная часть 2)

Реализуйте алгоритмы, основанные на сравнении элементов вектора типов. Как сравниваются типы? - Да очень просто, может
быть очень много критериев. Например, по числу уровней косвенности (указателей), по размеру (`sizeof`), по иерархии
наследования (предок-потомок). Сортировка по этим критериям может пригодиться, например, для более эффективной генерации
кода/классов (известно, в частности, что расположение полей в структуре в порядке убывания размера, как правило,
приводит к меньшему размеру самой структуры).

Всюду ниже предполагается, что `Compare` - шаблон структуры, принимающий два параметра-типа и имеющий статическое поле
`value`, которое хранит флаг, верно ли что первый тип меньше второго.

* `MinElement<TV, Compare>` содержит тип-член `type` с элементом вектора `TV`, который не больше остальных (если вектор
пуст, то `type` быть не должно);
* `MaxElement<TV, Compare>` содержит тип-член `type` с элементом вектора `TV`, который не меньше остальных (если вектор
пусть, то `type` быть не должно);
* `Merge<TV1, TV2, Compare>` содержит тип-член  `type` с вектором, полученным в результате слияния отсортированных
векторов `TV1` и `TV2` (согласно сравнению `Compare`);
* `Sort<TV, Compare>` содержит тип-член `type` с отсортированной версией вектора `TV`.

Для всех структур определите псевдоним `***T` с соответствующим низлежащим типом `type`, где `***` - имя структуры.

Примеры применения ищите в файле с тестами.
