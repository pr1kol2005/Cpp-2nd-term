### Iterator traits

*Понимание того, какого типа итератор, играет важную роль в написании эффективного обобщенного кода. В языке C++ эта
задача решается с помощью специального класса `std::iterator_traits`, который определяет внутренний тип
`iterator_category`. Правда для его работы (до C++20) требуется определить соответствующие внутренние типы в самом
классе итератора (либо специализировать `std::iterator_traits`). В этом задании мы реализуем свои версии определителей
категорий итераторов на основе их синтаксических свойств, с помощью механизма SFINAE.*

##### SFINAE

TODO

##### Задание

Необходио реализовать следующие шаблонные переменные:

* `kIsDereferenceableV<T>` - применима ли операция разыменования (`*`) к объекту типа `T`;
* `kIsIncrementableV<T>` - применимы ли операции инкремента (префиксного и постфиксного `++`) к *lvalue* типа `T`;
* `kIsDecrementableV<T>` - применимы ли операции декремента (префиксного и постфиксного `--`) к *lvalue* типа `T`;
* `kIsArrowDereferenceableV<T>` - применима ли операция косвенного доступа (`->`) к объекту типа `T` (будем считать,
что данная операция применима ко всем указателям и классам с перегруженной операцией `->`);
* `kIsEqualityComparableV<T>` - применима ли операция сравнения на равенство (`==`) к объектам типа `T`, **и** приводим
ли результат операции к типу `bool` (проверять существование операции `!=` не требуется);
* `kIsOrderedV<T>` - применима ли операция сравнения на меньше (`<`) к объектам типа `T`, **и** приводим ли результат
операции к типу `bool` (проверять существование других операций не нужно);
* `kIsSubtractableV<T>` - применима ли операция разности (`-`) к объектам типа `T`. **Также** определите шаблонный
псевдоним `DifferenceType<T>`, который совпадает с типом результата разности объектов типа `T`;
* `kHasIntegralArithmeticV<T>` - применимы ли операции присваивающей суммы и вычитания (`+=`, `-=`) к *lvalue* типа `T`
слева и `DifferenceType<T>` справа, **и** является ли `DifferenceType<T>` целочисленным типом;
* `kIsSubscriptableV<T>` - применима ли операция доступа по индексу (`[]`) к объекту типа `T` и `DifferenceType<T>`,
**и** является ли `DifferenceType<T>` целочисленным типом;
* `kIsIteratorV<T>` - является ли тип `T` итератором, а именно: будем считать тип итератором, если он 1) имеет
конструктор копирования, 2) имеет копирующее присваивание, 3) имеет деструктор, 4) имеет операцию разыменования, 5)
имеет операции инкремента;
* `kIsInputIteratorV<T>` - принадлежит ли тип `T` категории *Input Iterator*, а именно: будем считать тип итератором
ввода, если он 1) является итератором, 2) сравним на равенство, 3) имеет операцию `->`;
* `kIsForwardIteratorV<T>` - принадлежит ли тип `T` категории *Forward Iterator*, а именно: будем считать тип прямым
итератором, если он 1) является итератором ввода, 2) имеет конструктор по умолчанию;
* `kIsBidirectionalIteratorV<T>` - принадлежит ли тип `T` категории *Bidirectional Iterator*, а именно: будем считать
тип двунаправленным итератором, если он 1) является прямым итератором, 2) имеет операции декремента;
* `kIsRandomAccessIteratorV<T>` - принадлежит ли тип `T` категории *Random Access Iterator*, а именно: будем считать тип
итератором, если он 1) яаляется двунаправленным итератором, 2) имеет операцию вычитания, 3) имеет операции присваивающих
суммы и вычитания, 4) имеет операцию доступа по индексу, 4) имеет операцию сравнения на меньше.

При реализации разрешается пользоваться сущностями из `<type_traits>`.
