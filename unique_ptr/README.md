### UniquePtr

*Умные указатели реализуют важную идиому C++ - RAII (Resource Acquisition Is Initialization) и позволяют не заботиться о
ручном управлении памятью, так как инкапсулируют управление ресурсами посредством конструкторов и деструкторов.*

#### std::unique_ptr (C++11)

С++ предоставляет шаблонный класс `std::unique_ptr` (https://en.cppreference.com/w/cpp/memory/unique_ptr) для безопасной
работы с динамически выделенной памятью (и другими ресурсами). В `std::unique_ptr` перегружены все необходимые операции
для комфортной работы с объектами так, как если бы это были обычные указатели (которые еще память за собой очищают).
Объекты этого класса считаются единственными владельцами ресурса, на который они указывают, поэтому эти объекты нельзя
копировать, но можно перемещать - передавать владение другому объекту. Использование `std::unique_ptr` почти не
накладывает дополнительных вычислительных расходов, поэтому пользоваться им так же эффективно, как и обычными
указателями, и при этом гораздо безопаснее.

```c++
#include <memory>
// ...
std::unique_ptr<int> ptr(new int(10));
std::cout << *ptr << '\n';  // 10

// std::unique_ptr<int> copy = ptr; копирование запрещено
std::unique_ptr<int> moved = std::move(ptr);  // теперь ptr пуст
std::cout << *moved << '\n';  // 10

auto rational = std::make_unique<Rational>(1, 2);
// эквивалентно std::unique_ptr<Rational> rational(new Rational(1, 2));
std::cout << rational->Numerator() << ' ' << rational->Denominator() << '\n';  // 1 2

// delete вызовутся автоматически в деструкторах!
```

#### Задание

Реализуйте шаблон `UniquePtr` - упрощенный аналог класса умного указателя с уникальным владением, `std::unique_ptr`
(C++11).

#### Детали реализации

Шаблонный класс должен поддерживать:
* Конструктор по умолчанию (создает нулевой указатель).
* Конструктор от указателя (сохраняет указатель на объект).
* Конструктор копирования и копирующее присваивание должны отсутствовать.
* Перемещающий конструктор и перемещающее присваивание должны передавать владение объектом.
* Метод `Release()`, который отлучает класс от владения текущим ресурсом и возвращает указатель на него.
* Метод `Reset(T* ptr = nullptr)`, меняет указатель, которым владеет объект (старый ресурс удаляется).
* Метод `Swap(UniquePtr<T>&)`.
* Метод `Get()`, возвращающий указатель на объект.
* Оператор разыменовывания `operator*`.
* Оператор "стрелочка" `operator->`.
* Явный оператор приведения к `bool` (`operator bool`).

**Замечания.**
1. https://en.cppreference.com/w/cpp/memory/unique_ptr

2. Решение должно состоять из одного файла `unique_ptr.h`

#### Дополнительное задание

Дополнительно можете реализовать внешнюю шаблонную функцию `MakeUnique`, принимающую произвольное число параметров и
возвращающую `UniquePtr` на объект созданный с помощью данных параметров конструктора. В этом случае добавьте в файл с
решением директиву `#define MAKE_UNIQUE_IMPLEMENTED`.
