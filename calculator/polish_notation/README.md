### Калькулятор (Часть 2)

*Когда говорят "компьютерная программа", одно из первых, что приходит на ум, — калькулятор. Действительно, изначальное
назначение компьютеров - производить математические вычисления. И кажется, это настолько базовая задача, что написать
калькулятор на любом известном вам языке программирования не составляет никакого труда. Тем не менее оказывается, что
это не такая уж тривиальная и скучная задача. Как, например, вычислить значение, заданное входом
"1 * (((2 * 3) * (4 + 5) + 6 + 7) * (8 * 9 + 10 * 11) * 12)"? Данная задача в трех частях ответит на этот вопрос.*

### Polish Notation

Трудоемкость написания калькулятора заключается в сложности определения порядка выполняемых действий и построения дерева
разбора выражения. [*Дерево разбора выражения*](https://en.wikipedia.org/wiki/Binary_expression_tree) - корневое дерево,
вершинами которого являются операции, а дети вершин - выражения (поддеревья), являющиеся их операндами. В листьях дерева
находятся числа (константы).

Выражения записанные в [польской нотации](https://en.wikipedia.org/wiki/Polish_notation) очень просты для разбора, так
как операции в ней уже записаны в нужном для вычисления порядке (в порядке pre-order обхода дерева).

*Пример:*
```
"+ 3 4": читаем оператор + -> он бинарный -> читаем первый и второй операнд, 3 и 4 -> получаем результат операции 7
  +
 / \
3   4

"+ 3 * 4 5": извлекаем оператор + -> он бинарный -> вычисляем первый операнд - 3
-> второй операнд - результат операции * -> вычисляем его операнды (аналогично первому примеру)
-> вычисляем результат выражения
  +
 / \
3   *
   / \
  4   5
```

Формально, каждое значение (токен) в польском выражении можно считать некоторой операцией. Пусть дан массив токенов и в
данный момент рассматриваем токен в позиции `pos`. Построение дерева разбора в общем случае выглядит так:
1. Определяется тип операции и ее арность (количество операндов). Сдвигаем `pos` на 1 элемент вправо.
2. Если операция не требует аргументов (константа), то возвращаем ее в качестве результата.
3. Если операция унарная, рекурсивно строим поддерево для операнда, сохраняем его в соответствующее поле операции,
   возвращаем операцию (корень поддерева).
4. Если операция бинарная, рекурсивно строим поддерево первого аргумента, второго аргумента, сохраняем их в поля объекта
   нужной бинарной операции, возвращаем этот объект в качестве ответа (корня поддерева).

Например, возведение в квадрат - унарная операция: она извлекается; далее строится операнд посредством обработки
следующей операции в массиве; мы знаем, что результат обработки - это операция, результат которой будет выступать
аргументом; сохраняем ее в поле объекта класса `Square`; возвращаем готовую операцию `Square`.

Сумма - бинарная операция: она извлекается; строится первый операнд; результат записывается в поле класса `Sum`;
строится второй операнд; второй операнд сохраняется в поле `Sum`; возвращаем полученный объект `Sum`.

*Пример:*
```
"+ sqr 3 -5"
1. Запускаем построение выражения.
2. '+': создаем объект типа Sum
3. Рекурсивно запускаем построение первого операнда
    3.1. 'sqr': создаем объект типа Square
    3.2. Рекурсивно запускаем построение операнда для Square
        3.2.1. '3': создаем объект Constant(3) возвращаем его в качестве результата.
    3.3. Сохраняем результат рекурсивного вызова в поле объекта Square.
    3.4. Все операнды построены, возвращаем объект Square
4. Сохраняем результат рекурсивного вызова в первое поле объекта Sum.
5. Рекурсивно запускаем построение второго операнда.
    5.1 '-5': создаем объект Constant(-5) возвращаем его в качестве результата.
6. Сохраняем результат рекурсивного вызова во второе поле объекта Sum.
7. Возвращаем объект Sum.

В итоге возвращается следующее бинарное дерево:
    +
   / \
 sqr -5
  |
  3
```

Видно, что построение дерева разбора выражения сводится к построению первой операции (корня) в массиве (все остальное
строится рекурсивно). В случае, если выражение было составлено верно, то в результате рекурсивных вызовов `pos` окажется
в позиции следующей за последним токеном (будет равен длине массива).

#### Детали реализации

Решение состоит из двух частей - токенизации (уже реализована в части 1) и построения дерева разбора.

В файле `expressions.h` необходимо объявить классы операций.

* `IExpression` - абстрактный класс для представления произвольной операции.
  * Содержит единственный публичный метод `int Calculate() const`, который вычисляет свои операнды и возвращает
    результат применения операции.
* `Constant` - наследник `IExpression`.
  * Имеет конструктор от `int`, сохраняющий значение константы в свое поле.
  * Определяет метод `Calculate` (просто возвращает свое значение).
* `IUnaryOperation` - абстрактный класс, наследник `IExpression`, представляющий произвольную унарную операцию.
  * Имеет конструктор от `std::unique_ptr<IExpression>`, который сохраняет переданный указатель в поле (операнд).
  * Имеет метод `int Operation(int operand) const`, который применяет операцию к вычисленному операнду.
  * Определяет метод `Calculate` путем вычисления операнда и применения к нему операции.
* `IBinaryOperation` - абстрактный класс, наследник `IExpression`, представляющий произвольную бинарную операцию
  * Имеет конструктор от двух `std::unique_ptr<IExpression>`, который сохраняет переданные указатели в поля (операнды).
  * Имеет метод `int Operation(int lhs, int rhs) const`, который применяет операцию к вычисленным операндам.
  * Определяет метод `Calculate` путем вычисления операндов и применения к ним операции.
* Классы операций `Sum` (+), `Subtract` (-), `Multiply`(*), `Divide`(/), `Residual`(%), `Minimum`(min), `Maximum`(max),
  `AbsoluteValue`(abs), `Square`(sqr), которые должны быть унаследованы от соответствующих абстрактных классов
  (`IUnaryOperation` или `IBinaryOperation`) и реализовать соответствующий метод `Operation`.
  В классы описанные выше вы можете добавлять свои приватные/публичные методы. Самостоятельно определите, какие методы
  должны быть виртуальными/чисто виртуальными. Для интереса можете добавлять свои операции. Если все реализовано верно, то
  для этого будет достаточно ввести новый класс и правильно его унаследовать.

Также нужна функция `int CalculatePolishNotation(std::string_view input)`, которая токенизирует вход, строит дерево разбора
и запускает вычисление выражения.
Прототип и реализацию описать в `polish_notation.h` и `polish_notation.cpp`.

Программа должна бросать исключения `UnknownSymbolError`, если в результате токенизации был получен неизвестный токен;
`WrongExpressionError`, если выражение составлено некорректно.

Гарантируется, что все промежуточные результаты помещаются в `int`.

Для простоты будем считать, что все токены разделены пробелами (произвольным их количеством).

**Замечания.**

1. Вам понадобится токенизатор из предыдущего задания. Чтобы включить заголовочный файл оттуда, в include директиву
   пропишите относительный путь до файла (`#include "../tokenize/tokenize.h"`)