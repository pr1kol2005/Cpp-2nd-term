### Калькулятор (Часть 3)

*Когда говорят "компьютерная программа", одно из первых, что приходит на ум, — калькулятор. Действительно, изначальное
назначение компьютеров - производить математические вычисления. И кажется, это настолько базовая задача, что написать
калькулятор на любом известном вам языке программирования не составляет никакого труда. Тем не менее оказывается, что
это не такая уж тривиальная и скучная задача. Как, например, вычислить значение, заданное входом
"1 * (((2 * 3) * (4 + 5) + 6 + 7) * (8 * 9 + 10 * 11) * 12)"? Данная задача в трех частях ответит на этот вопрос.*

### Calculator

Поздравляем, вы добрались до "Босса". В этом задании вы научитесь производить разбор арифметических выражений и
реализуете практически полноценный калькулятор.

Основные идеи разбора арифметических выражений во всех подробностях представлены
[здесь](https://sites.google.com/site/slipstak2/arithm_article.pdf?attredirects=0&d=1).

*TL;DR :* Арифметическое выражение - это сумма нескольких (одного и более) слагаемых. Слагаемое - это произведение
(деление) нескольких множителей. Множитель - это константа, либо выражение заключенное в скобки. Таким образом,
необходимо уметь выделять в исходном тексте каждую из этих трех сущностей ~~в виде гномика~~.

Парсинг множителя - это простой разбор двух случаев: если следующий токен константа, то множитель - это константа. Если
открывающаяся скобка, то множитель равен выражению, стоящему в скобках (обрабатывается с помощью парсинга выражения).

Парсинг выражения начинается с парсинга слагаемого. После этого выражение полагается равным полученному первому
слагаемому. Пусть уже построено выражение некоторой длины. Тогда, если следующий элемент это знак `+` или `-`, то
парсится следующее слагаемое, а выражение полагается равным сумме (разности) уже построенного выражения и нового
слагаемого.

Парсинг слагаемого эквивалентен парсингу выражения с точностью до замены знаков `+`, `-` на `*`, `/`, `%`.

*Пример.*
```
(2 + 3) * 4

1. Парсинг выражения [1] начинается с парсинга слагаемого
2. Парсинг слагаемого [2] вызывает парсинг множителя.
3. Парсинг множителя [3] читает первый токен. Это открывающаяся скобка. Значит необходимо
распарсить выражение, которое стоит внутри.
4. Рекурсивно запускаем парсинг выражения [4], который запускает парсинг слагаемого [5],
который в свою очередь запускает парсинг множителя [6].
5. Парсинг множителя [6] видит константу '2', на этом его полномочия все. Он возвращает
выражение Constant(2).
6. Возвращаемся в [5]. Слагаемое полагаем равным вернувшемуся значению Constant(2).
7. Следующий символ '+', поэтому слагаемое [5] успешно построено. Возвращаем результат.
8. Возвращаемся в [4]. Парсинг слагаемого вернул Constant(2), поэтому пока оно совпадает
с итоговым выражением. Но следующий символ '+', поэтому необходимо распарсить следующее
слагаемое [7].
9. Аналогично [5], [7] вернет слагаемое Constant(3).
10. Возвращаемся в [4]. Парсинг слагаемого [7] вернул Constant(3). Итоговое выражение
полагаем равным сумме (Sum) текущего выражения (Constant(2)) и очередного слагаемого
Constant(3). Следующий символ - закрывающаяся скобка, значит выражение окончено,
возвращаем Sum(Constant(2), Constant(3)) в качестве ответа.
11. Этот результат примет [3] и вернет в качестве ответа.
12. Этот результат попадет в [2]. Текущее значение слагаемого полагается равным
Sum(Constant(2), Constant(3)). Но следующий символ - '*', поэтому запускаем парсинг
второго множителя [8].
13. Парсинг множителя [8] видит, что это константа '4', поэтому сразу возвращает
Constant(4).
14. Возвращаемся в [2]. Слагаемое полагаем равным произведению текущего значения
(Sum(Constant(2), Constant(3))) и Constant(4). Следующего токена нет, поэтому
возвращаем ответ.
15. В [1] попадает Multiply(Sum(Constant(2), Constant(3)), Contant(4)). Токены все
разобраны, поэтому это и есть ответ.
16. Осталось только вызвать Calculate от полученного выражения

    *
   / \
  +   4
 / \
2   3
```

#### Детали реализации

Решение состоит из двух частей - токенизация (понадобится токенизатор из части 1) и построение дерева разбора (парсинг).

Используйте классы выражений из задачи `PolishNotatin` (`expressions.h`). В этом задании вам понадобятся только операции
+, -, *, /, % и константы. Тем не менее подумайте, как поддержать возможность использования других (например, унарных)
операций.

В файлах `parser.h` и `parser.cpp` объявите и определите функции `ParseExpression`, `ParseAddendum`,
`ParseMultiplier`, возвращающие умный указатель на выражение и принимающие `const std::vector<Token>& tokens`(токены) с
`size_t& pos` (позиция текущего токена).

В файлах `calculator.h` и `calculator.cpp` определите функцию `int CalculateExpression(std::string_view input)`,
принимающую выражение в виде строки и возвращающую ответ.

Программа должна бросать исключения `UnknownSymbolError`, если в результате токенизации был получен неизвестный токен и
`WrongExpressionError`, в случае возникновения ошибок при вычислении или разборе (см. примеры в тестах).

Все промежуточные результаты помещаются в `int`.

Для простоты будем считать, что все токены разделены пробелами (произвольным их количеством).

**Замечания.**

1. Решение должно состоять из файлов: `calculator.h`, `calculator.cpp`, `parser.h`, `parser.cpp`.
2. Вам понадобится решения предыдущих частей. Чтобы включить заголовочный файл оттуда пропишите в include директиве
   относительный путь до нужного заголовка (например, `#include "../tokenizer/tokenize.h"`)
 