### StringView

*В этом задании вам предстоит реализовать класс, который представляет собой невладеющую обертку над C-style строками,
совмещающий в себе их легкость и удобство использования от ООП.*

#### std::string_view (C++17)

Класс `std::string` (которым пользоваться все еще пока запрещено) в большинстве случаев удобнее в использовании, безопаснее и иногда эффективнее C-style строк. Однако
бывают ситуации, в которых использование последних гораздо предпочтительнее. Например, обращение к элементам строки это
всегда (ну, или [почти всегда](https://blogs.msmvps.com/gdicanio/2016/11/17/the-small-string-optimization/)) обращение к
памяти в куче, что требует некоторых накладных расходов. Также часто приходится заводить константные строки со
статическим временем жизни (обозначение допустимых команд принимаемых программой и т.п.) и для каждой из них необходимо
вызвать конструктор, выделить память в куче, заполнить... В то время как строковые литералы заводятся в статической
области памяти еще до начала выполнения программы. А если глобальный (статический) объект `std::string` бросит
исключение при создании? Тогда его нельзя будет обработать и программа аварийно завершится, так толком и не начав
работать.

Хорошо, давайте в этих ситуациях использовать `const char*`. Но это же снова `strlen`, работающий за линейное время,
`strcmp` вместо операторов сравнения, небезопасный доступ к данным...

В C++17 появился класс `std::string_view`, который является легковесной оберткой над C строками. Все, что он хранит,-
это указатель на константную последовательность символов и ее размер. Для доступа и работы с ней используются интуитивно понятные методы без необходимости задумываться о завершающем нулевом символе. Более того, последовательность символов не обязана быть нуль-терминированной, так как размер строки хранится в отдельном поле. Таким образом, мы нивелируем недостатки `const char*`, в полной мере используя его преимущества.

*Пример:*

```c++
const char* cstyle = "very_very_long_string_here";  // c-style строка

std::string s = cstyle;  // выделение памяти в куче (долго + потенциально небезопасно)

std::string_view sv = cstyle;  // просто сохраняем указатель в поле класса и вычисляем длину

std::strlen(cstyle);  // всегда O(n)

sv.size();  // всегда O(1)
```

#### Детали реализации

Идея описана выше. Особенностей реализации нет (как слышится так и пишется).

Реализуйте класс `StringView` с поддержкой:

* Конструктора по умолчанию (`nullptr` строка).
* Конструктора от `const char*` (с подсчетом длины). Этот конструктор должен допускать неявные преобразования. Чтобы на это не ругался линтер, добавьте к строке с объявлением комментарий `"// NOLINT"`.
* Конструктора от `const char*` и `size_t` (длина передается вторым параметром).
* Операции `[]`.
* Методов `Front()` и `Back()`, которые возвращают первый и последний символ строки соответственно.
* Методов `Size()` и `Length()`, которые возвращают длину строки.
* Метод `Empty()` проверяет строку на пустоту.
* Метод `Data()` возвращает указатель на начало строки.
* Метода `Swap(StringView&)`.
* Метода `RemovePrefix(size_t prefix_size)`, который сдвигает начало строки на `prefix_size`.
* Метода `RemoveSuffix(size_t suffix_size)`, который сдвигает конец строки на `suffix_size`.
* Метода `Substr(size_t pos, size_t count = -1)`, который формирует из вызывающего объекта `StringView` на подстроку с
  началом `pos` и длины `min(count, Size() - pos)` (если `pos` выходит за границы, то бросает `StringViewOutOfRange`).

**Замечания.**
1. https://en.cppreference.com/w/cpp/string/basic_string_view

2. Решение должно состоять из двух файлов: `string_view.h` и `string_view.cpp`

3. В задаче нет скрытых тестов - все тесты публичные (`string_view_public_test.cpp`).
