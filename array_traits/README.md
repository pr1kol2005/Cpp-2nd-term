### Array Traits

*Метапрограммирование на шаблонах позволяет проверять свойства типов данных на этапе компиляции, а также изменять типы
по необходимости. Например, известно, что `T` - это ссылка на другой тип (допустим, `int&`). Как получить тот же тип
`T`, но без ссылочной аннотации, например, для того, чтобы можно было объявить вектор таких элементов (массивы ссылок,
как известно, запрещены).

В этом задании вы попрактикуетесь в написании собственных определителей и модификаторов свойств типов.*

##### <type_traits>

Заголовочный файл `<type_traits>` содержит большое количество предопределенных классов/псевдонимов/переменных, которые
решают задачу обнаружения/изменения свойств типов, а также несколько служебных сущностей, которые позволяют упростить
написание своих собственных классов.

Со всеми ними полезно ознакомиться, однако в этом задании разрешено использовать только `std::integral_constant`,
`std::bool_constant`, `std::true_type`, `std::false_type`, `std::conjunction`, `std::disjunction`.

##### Задание

Реализуйте свои собственные определители/модификаторы типов для массивов:

* Шаблонную переменную `kIsArrayV<T>`, которая определяет, является ли тип `T` массивом;
* Шаблонную переменную `kRankV<T>`, которая хранит общий ранг массива (количество размерностей);
* Шаблонную переменную `kSizeV<T>`, которая хранит размер массива (на верхнем уровне);
* Шаблонную переменную `kTotalSizeV<T>`, которая хранит общий размер массива, включая все вложенные подмассивы;
* Шаблонный псевдоним `RemoveArrayT<T>`, который задает низлежащий тип массива (на верхнем уровне);
* Шаблонный псевдоним `RemoveAllArraysT<T>`, который задает тип, полученный после отбрасывания всех вложенных массивов.

Примеры применения доступны в файле с тестами

**Замечание.** в решении можно использовать только описанные выше служебные классы из std. Если необходимо что-то
дополнительное, реализуйте это самостоятельно.
