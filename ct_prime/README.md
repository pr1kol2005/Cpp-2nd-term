### Compile Time Prime

*В этом задании мы немного поностальгируем и реализуем алгоритм проверки числа на простоту. Но уже на этапе компиляции.*

##### Подзадача 1. Квадратный корень

Для начала научимся искать целочисленный квадратный корень произвольного неотрицательного числа `N`. То есть наибольшее
неотрицательное число `S`, что `S * S <= N`.
Простой перебор значений является неэффективной стратегией, а также в случае метапрограммирования на шаблонных
параметрах приведет к очень глубокой рекурсии.
Поэтому решать задачу будем с помощью бинарного поиска.

Реализуйте бинарный поиск во время компиляции, который определит целочисленный квадратный корень числа `N`. Результат
должен храниться в шаблонной переменной `kSqrtV<N>`.

*Подсказка: не инстанцируйте лишние шаблоны. То есть убедитесь, что ветки поиска, которые ведут в отброшенные части
отрезка, не инстанцируются.*

##### Подзадача 2. Поиск делителей на подотрезке

Теперь нужно реализовать перебор значений на этапе компиляции и определение наличия/отсутствия делителей. В примитивном
случае все довольно просто - цикл на шаблонах = рекурсия. Но в случае большого отрезка мы снова упираемся в ограничение
на глубину рекурсии. Поэтому воспользуемся стратегией "разделяй и властвуй". Поиск делителей на отрезке = поиск
делителей на первой половине + поиск делителей на второй половине. Случай, когда отрезок состоит из одного элемента
тривиален. С помощью такого необычного (с точки зрения обычного программирования) перебора мы уменьшим максимальную
глубину рекурсии с линейной до логарифмической.

Реализуйте описанную процедуру определения наличия делителя числа `N` на отрезке `[L, R]` во время компиляции. Результат
должен храниться в шаблонной переменной `kHasDivisorOnV<N, L, R>`

##### Подзадача 3. Проверка на простоту

Используя значения из предыдущих пунктов, определите шаблонную переменную `kIsPrimeV<N>`, которая определяет является ли
число `N` простым во время компиляции.

**Замечание.** Все пункты можно решить просто и легко с помощью
[`constexpr` функций](https://en.cppreference.com/w/cpp/language/constexpr). Однако в этом задании их использование
запрещено и ожидается решение с помощью механизма специализации шаблонов ~~чтобы жизнь медом не казалась~~ для учебных
целей.
