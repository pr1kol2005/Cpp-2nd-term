### Optional

*Это задание познакомит вас с основами ручного управления временем жизни объектов на примере класса `Optional`.*

При создании объектов на стеке компилятор самостоятельно выделяет память достаточную для хранения объекта и
инициализирует объект, вызывая соответствующий конструктор, а при выходе из блока самостоятельно очищает память и
завершает время жизни объекта посредством вызова деструктора.

Если речь идет про динамическую область памяти, то этот процесс частично контролируется пользователем - операция `new`
заставляет выделить память под объект в куче и создать его там же, операция `delete` инициирует вызов деструктора и
освобождает выделенную память.

А что, если хочется самостоятельно определять в какой момент объект должен быть создан и уничтожен, то есть не
привязывать время жизни объекта к памяти, которая его содержит? Это может быть полезно, например, для эффективной работы
`std::vector<T>` - если объекты типа `T` требуют много ресурсов на создание, то может быть накладно иметь `capacity`
объектов, когда реально используется только `size` из них. Для решения этой проблемы `std::vector` хранит лишь "сырую"
память достаточную для хранения `capacity` объектов, а сами объекты создаются и удаляются вручную по мере необходимости.

##### Placement new и явный вызов деструктора

Для ручного создания объекта по конкретному месту в памяти (заранее выделенного на стеке или в куче) можно
воспользоваться специальной формой оператора `new` - 
[*placement new*](https://ru.wikipedia.org/wiki/New_(C%2B%2B)#Placement_new).

Пусть `ptr` - указатель на область памяти достаточного размера для хранения объекта типа `T`. Чтобы создать объект в
данном месте можно воспользоваться следующим синтаксисом:
```c++
new(ptr) T(args...);  // args... - аргументы конструктора
```

Заметьте, что отличие состоит в явном указании адреса в скобках и *отсутствии выделения дополнительной памяти*.

Приведем пример **неправильного использования** *placement new*:

```c++
A a;                 // создаем объект типа A
new(&a) A("param");  // пересоздаем объект, деструктор старого объекта при этом не вызывается!
```

Для корректной работы предыдущего примера необходимо удалить старый объект перед созданием нового:
```c++
A a;                 // создаем объект типа A
a.~A();              // явно вызываем деструктор старого объекта
new(&a) A("param");  // создаем новый объект
```

Код вида `a = A("param");` логически эквивалентен приведенному выше, но отличается с точки зрения времени жизни
объектов. Кроме того, код выше работает и в случае, когда для класса `A` не определен оператор присваивания.

Важно отметить, что после последнего создания явно вызвать деструктор не нужно, так как компилятор вызывает его
самостоятельно при выходе из блока:
```c++
A a;                 // создаем объект типа A
a.~A();              // явно вызываем деструктор старого объекта
new(&a) A("param");  // создаем новый объект
a.~A();              // UB: деструктор вновь вызовется при выходе из блока
```

Для создания объекта "с нуля" в сырой памяти нужно сначала предоставить эту память, а затем приступить к созданию:

```c++
char memory[sizeof(A)];  // создаем сырую память размера sizeof(A) байт
A* obj = new(memory) A("param");  // создаем объект A, возвращается тот же указатель, но типа A*
// ... use of A
obj->~A();  // важно самостоятельно вызвать деструктор! memory будет освобожден как массив char, а не как объект A
```

Аналогичный пример в динамической памяти:
```c++
char* memory = new char[sizeof(A)];  // или operator new(sizeof(A));
A* obj = new(memory) A("param");
// ... use of A
obj->~A();
delete[] memory;  // так как выделяли массив char, то и удалять нужно массив char
                  // или operator delete(memory);
```

Вместо массива `char` в качестве сырой памяти под объекты можно использовать стандартный тип
[std::aligned_storage_t](https://en.cppreference.com/w/cpp/types/aligned_storage).

##### std::optional (C++17)

Шаблон `std::optional` предоставляет безопасный интерфейс для управления временем жизни объектов. Он принимает ровно 1
шаблонный параметр (тип хранимого объекта) и может находиться в одном из двух состояний - объект жив или объект мертв.

В любой момент времени можно узнать состояние объекта (`has_value`), или изменить его (`emplace`, `reset`). При этом
класс самостоятельно принимает решение о том в какой момент вызывать деструктор/конструктор объекта, освобождая
пользователя от этих забот.

**Пример:**

```c++
std::optional<std::vector<int>> opt;  // opt не содержит внутри себя вектора (даже пустого)
opt.has_value();  // false
opt = std::vector<int>(3);  // теперь содержит вектор из 3 чисел
opt.has_value();  // true
(*opt)[2];  // для обращения к объекту нужно "разыменовать" opt или вызвать метод value()
opt.reset();  // вектор уничтожен, opt теперь ничего не хранит
```

Этот класс может быть полезен, например, для реализации функций, которые не всегда должны что-то возвращать:

```c++
std::optional<double> Divide(double x, double y) {
    if (y == 0.0) {
        return {};  // или std::nullopt
    }
    return x / y;
}

auto res = Divide(1.0, 0.0);
if (res) {  // умеет неявно преобразовываться в bool
    std::cout << *res;
}
```

##### Детали реализации

Реализуйте шаблон `Optional<T>`, упрощенный аналог `std::optional<T>`. В полях шаблона сохраните память (массив `char`
или `std::aligned_storage_t`) достаточного размера (память должна располагаться на стеке!), а также булевское поле, в
котором будет храниться информация о том жив ли объект. Шаблонный класс должен поддерживать следующие методы:

* *Конструктор по умолчанию*. Создает `Optional` с "мертвым" объектом.
* *Конструктор копирования*. Создает копию, если копируемый объект жив, и пустой `Optional` иначе.
* *Конструктор перемещения*. Если перемещаемый `Optional` пуст, то создается пустой объект. Иначе перемещаем объект из
другого `Optional`. При этом старый `Optional` по прежнему остается живым!
* *Неявный конструктор от `const T&` и `T&&`*. Создает `Optional` созданный с помощью переданного объекта (копированием
  или перемещением)
* *Деструктор*. Вызывает деструктор объекта, если тот жив, и ничего не делает, если мертв.
* *Копирующее и перемещающее присваивание*. Если копируемый(перемещаемый) объект мертв, то и свой объект становится
  мертвым. Иначе своему объекту нужно соответствующим образом присвоить другой (и если был мертв, то оживить).
* *Присваивание от `const T&` и `T&&`*. Аналогично предыдущему (только копируемый объект априори жив).
* *bool HasValue()*. Возвращает жив объект, либо нет.
* *Явное приведение к bool*. Аналогично предыдущему.
* *Value()*. Возвращает ссылку на объект. Если объект мертв, то бросается исключение `BadOptionalAccess`
  (которое тоже надо реализовать). Поддержать константную и неконстантную версии.
* *Константный и неконстантный `operator*`*. Аналогичен `Value`, но не осуществляет проверок.
* *T& Emplace(args...)*. Принимает аргументы конструктора, с которыми нужно пересоздать объект (если он был жив, то
  вызвать деструктор и создать заново).
* *void Reset()*. Уничтожить объект, если тот был жив.

**Замечания.**

1. https://en.cppreference.com/w/cpp/utility/optional

2. Решение должно состоять из одного файла `optional.h`

3. Существует неприятная проблема связанная с использованием указателя на "сырую" память, которая была ранее занята
   другим объектом (https://en.cppreference.com/w/cpp/utility/launder). Для упрощения реализации мы игнорируем эту
   проблему (она проявляется только при работе с объектами с константными или ссылочными полями, в тестах таких случаев
   нет).
