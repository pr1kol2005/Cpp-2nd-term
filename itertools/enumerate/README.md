### Itertools

*Одним из минусов языка C++ является отсутствие удобного интерфейса работы с последовательностями и промежутками
значений, который, по большому счету сводится к ручному написанию циклов и работе со встроенными итераторами. С
введением библиотеки [\<ranges\>](https://en.cppreference.com/w/cpp/ranges) в C++20 ситуация заметно улучшилась. В этом
цикле задач мы попытаемся решить заявленную проблему средствами C++17.*

### Enumerate

Для прохода по контейнеру, который не поддерживает индексацию (`[]`),  и хранения порядкового номера текущего элемента
необходимо поддерживать его самостоятельно в отдельной переменной:
```c++
int i = 0;
for (auto it = container.begin(); it != container.end(); ++it, ++i) {
    // ...
}
```

Сравните, например, с языком Python:
```python
for i, x in enumerate(container):
    # ...
```

Хотелось бы иметь подобный лаконичный код и в C++ (благо range-based for завезли в C++11):

```c++
for (auto&& [i, x] : enumerate(container)) {
    // ...
}
```

Проблема в том, что в стандартной библиотеке (до C++20) нет сущности `enumerate`, которую можно было использовать в
подобном контексте. Ну а раз так - надо ее реализовать самостоятельно!

##### Детали реализации

Необходимо реализовать `Enumerate` (класс или функцию), который возвращает объект некоторого класса (вам нужно его
реализовать) с определенными методами `begin` и `end`. Эти методы должны возвращать итераторы, которые помимо
стандартного итератора контейнера хранят порядковый номер элемента, а при разыменовывании возвращают пару
"индекс-элемент".

**Примеры:** (больше примеров см. в тестах)
```c++
std::list<int> l{1, 2, 3, 4, 5};

for (auto p : Enumerate(l)) { ... }  // p in [{0, 1}, {1, 2}, {2, 3}, {3, 4}, {4, 5}]

for (auto&& [i, x] : Enumerate(l)) {
    x = 0;
}
// l == {0, 0, 0, 0, 0}
```

*Указание: вспомните как работает range-based for в C++*.

##### Дополнительное задание

При наивной реализации (описанной в задании) `Enumerate` не сможет работать со временными контейнерами:
```c++
for (auto&& [i, x] : Enumerate(std::vector<int>{1, 2, 3, 4, 5})) { ... }  // Undefined behaviour!
```

Это связано с тем, что цикл будет работать с "висячими" (невалидными) итераторами, так как контейнер, на который они
ссылаются, будет уничтожен.

Решить эту проблему можно с помощью специализации `Enumerate` на случай `rvalue` объектов. В этом случае в полях класса
необходимо сохранять не итераторы `begin` и `end`, а контейнер целиком. Так мы гарантируем, что сохраненный контейнер
не будет уничтожен до выхода из цикла, и итераторы всегда будут ссылаться на живой объект.

Добавьте директиву `#define TEMPORARY_ENUMERATE_IMPLEMENTED` в файл с решением для проверки дополнительного задания.
