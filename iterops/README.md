### Iterops

*Наличие итераторов различных категорий усложняет написание обобщенного кода, так как операции поддерживаемые одним
типом могут не поддерживаться другим. В частности, random access итераторы могут быть продвинуты на несколько шагов
вперед за O(1) с помощью `+=`, в то время как для bidirectional итераторов необходимо в цикле вызывать `++`. К счастью,
в стандартной библиотеке есть функции, которые позволяют единым образом работать со всеми итераторами и выбирают
наиболее эффективный способ выполнения той или иной операции на основании категории итератора.*

##### `std::advance`, `std::next`, `std::prev`, `std::distance`

Функция [`std::advance`](https://en.cppreference.com/w/cpp/iterator/advance) принимает итератор и количество шагов, на
которое нужно его продвинуть. При этом для random access итераторов используется `+=`, а для остальных цикл из `++`
(или `--`).

Функция [`std::next`](https://en.cppreference.com/w/cpp/iterator/next) аналогична `std::advance`, но может быть вызвана
без второго аргумента (продвигает итератор на 1) и не изменяет исходный итератор, а возвращает новый.

Функция [`std::prev`](https://en.cppreference.com/w/cpp/iterator/prev) аналогична `std::next`, но двигает итераторы в
обратном направлении (`--`).

Функция [`std::distance`](https://en.cppreference.com/w/cpp/iterator/distance) принимает пару итераторов (начало и
конец последовательности) и вычисляет расстояние между ними. Для random access итераторов работает за O(1), так как
использует вычитание одного итератора из другого, для остальных сложность линейная (продвигаем начало пока не встретим
конец).

**Пример:**
```c++
std::vector<int> v{1, 2, 3, 4, 5};
std::list<int> l{1, 2, 3, 4, 5};

auto v_it = v.begin();
auto l_it = l.begin();

std::advance(v_it, 3);  // <=>  v_it += 3
std::advance(l_it, 3);  // <=>  for (int i = 0; i < 3; ++i) { ++l_it; }

auto vv_it = std::next(v_it, 2);
auto ll_it = std::next(l_it, 2);

std::cout << std::distance(v_it, vv_it);  // 2  O(1)
std::cout << std::distance(l_it, ll_it);  // 2  O(distance)
```

##### Задание

Реализовать шаблонные функции `Advance`, `Next`, `Prev`, `Distance` (аналоги функций выше) с механизмом диспетчеризации
по типу переданного итератора.

##### Детали реализации

Категорию итератора можно получить с помощью класса `std::iterator_traits`: она определена в типе-члене
`iterator_category`.

```c++
using IteratorType = typename std::vector<T>::iterator;  // вспомните, зачем нужен typename
std::iterator_traits<IteratorType>::iterator_category category;  // category имеет тип std::random_access_iterator_tag
```

Как с помощью этой информации реализовать требуемый функционал? Наивная реализация не пройдет:
```c++
if (std::iterator_traits<IteratorType>::iterator_category == std::random_access_iterator) {  // 1
  iterator += n;  // 2
} else {
  for (int i = 0; i < n; ++i) {
    ++iterator;
  }
}
```

Во-первых, типы нельзя сравнивать с помощью `==` (по сути, в 1 написано что-то наподобие `int == float`). Во-вторых,
если итератор не поддерживает операцию `+=`, то вы получите ошибку компиляции (компилируются обе ветки `if` и в одной
из них написано что-то некорректное).

Для решения этих проблем в данной задаче предлагается использовать механизмы метапрограмирования из C++17, а именно:
* [constexpr if](https://en.cppreference.com/w/cpp/language/if#Constexpr_if) позволяет "отключать" ветки инстанцирования
при выполнении переданных compile-time условий;
* [std::is_same/std::is_same_v][https://en.cppreference.com/w/cpp/types/is_same] предоставляет аналог операции сравнения
на равенство для типов;
* наконец, если требуется не точная проверка соответствия типа, а, например, проверка на то, является ли один тип
наследником другого, то можно воспользоваться
[std::is_base_of/std::is_base_of_v](https://en.cppreference.com/w/cpp/types/is_base_of).
