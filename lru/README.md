### LRU

*Это задача-"соревнование" --- в ней вам предстоит не просто предъявить решение, но и написать тесты к нему.
Количество баллов за нее зависит от корректности вашего решения и количества решений, которые не прошли ваши тесты.*

##### LRU Map

Идея кэширования результатов довольно популярна и широко применяется в ситуациях, когда вычисление этого самого
результата может тратить довольно существенное время (или иной вид ресурса). Кратко напомним подход: результаты запросов
сохраняются в специальной структуре данных, из которой их в любой момент можно достать. Однако проблема в том, что при
достаточно большом числе запросов размер кэша будет играть немаловажную роль в эффективности работы системы (как по
времени, так и по памяти). В связи с этим необходимо озаботиться стратегией поддержания размера кэша в разумных рамках,
что включает в себя как алгоритм выбора объектов для хранения в кэше, так и алгоритм вытеснения потенциально не нужных
данных.

Одной из наиболее часто используемых стратегий является *LRU (Least Recently Used)*. Эта стратегия в первую очередь
вытесняет те элементы, которые были не востребованы дольше всего. Одним из вариантов реализации подхода может быть
следующий.

Кэш представляет собой контейнер фиксированного размера. При запросе сначала результат ищется в кэше, и если он найден,
то он возвращается и поднимается в списке недавно используемых элементов на первое место. Если же результата в кэше не
обнаружено, то он вычисляется, а затем кладется в кэш. При этом, если в момент добавления кэш уже заполнен полностью, то
из него удаляется элемент, к которому не обращались дольше всего.

##### Детали реализации

Реализуйте шаблонную структуру данных *LRUMap<Key, Value>*, которая представляет собой ассоциативный массив
ограниченного размера (отображение запросов - `Key` в результаты - `Value`). При добавлении элемента сверх допустимого
размера, она должна удалять самый "старый" из своих элементов (согласно стратегии LRU).

Структура должна поддерживать следующие операции (функционал может дополняться и уточняться в зависимости от
поступивших вопросов):
* Конструктор от максимального размера. Принимает целое **положительное число** - максимальный размер контейнера.
* Методы `Size`, `Empty`, `Capacity` - текущий размер, пустой ли контейнер, максимально допустимый размер.
* Метод `void Add(key, value)`, который добавляет в контейнер значение `value`, соответсвующее ключу `key`. Если ключ
`key` уже лежит в мапе, то необходимо обновить `value`. Пара `(key, value)` при этом (в любом случае) считается наиболее
недавно использованной.
* Метод `bool Contains(key)`, который проверяет наличие ключа `key` в мапе. **При наличии** элемент считается наиболее
недавно использованным.
* Метод `Get(key)`, который возвращает ссылку на найденное значение по ключу `key` и помечает его наиболее недавно
использованным. При отсутствии элемента необходимо бросить исключение `std::out_if_range`.
* Метод `GetOr(key, default_value)`, который возвращает найденное значение по ключу `key` и помечает его наиболее
недавно использованным. При отсутствии элемента необходимо вернуть `default_value` (значение в мапу при этом **не**
добавляется).
* Метод `Erase(key)`, который удаляет элемент при его наличии (при отсутствии ничего не происходит).
* Метод `Clear()`, который очищает мапу от элементов.
* Копирование и перемещение структуры должно работать корректно.

Можно считать, что типы `Key` и `Value` копируемы и noexcept-перемещаемы, для элементов типа `Key` определены операции
взятия хеша `std::hash<Key>` и сравнения (`==`, `!=`, `<`, ...).

При возникновении вопросов по функционалу структуры пишите в чат. В файле `lru_public_test.cpp` содержится лишь
**заготовка** тестов к задаче. Свои тесты располагайте в этом же файле. Можете дополнить существующие тесты, либо же
переписать под свои нужды. Старайтесь разделять тесты на логические секции. Тесты должны соответствовать условию задачи
-- проверка условий, методов, которые не описаны в текущем файле недопустима, такие файлы с тестами будут
проигнорированы. Вы можете включить в тесты проверку эффективности решений (256MB/1s в Я.Контесте). Обратите внимание,
что тесты будут запускаться с санитайзерами. Заведомо непроходимые тесты будут баниться. Не нужно подбирать тесты
максимально близкие к ограничениям, старайтесь поймать решения с плохой асимптотикой.

Написание тестов и реализация решения - разные задания. Теоретически можно отправить только одно из них (либо ни одно из
 них). Но проверять работоспособность решения без тестов и наоборот будет **крайне** проблематично.