### UnorderedSet

Реализуйте шаблонный класс `UnorderedSet`, аналог
[std::unordered_set](https://en.cppreference.com/w/cpp/container/unordered_set), который основан на хешировании методом 
цепочек с динамическим увеличением числа корзин.

Метод цепочек предполагает хранение массива, в каждой ячейке которого лежит корзина - список вставленных элементов с
одинаковыми хеш-значениями. Среднее время операций над такой структурой пропорционально степени загруженности таблицы
(`load_factor` = n_elements / n_buckets). При превышении `load_factor` некоторого значения (в задании = 1) происходит
перехеширование - создание нового массива корзин в, например, 2 раза большего размера и перенос старых элементов в новые
корзины.

В простейшем варианте достаточно хранить вектор (`std::vector`) списков (`std::list` / `std::forward_list`) и выполнять
операции над ним. Более эффективные техники описаны ниже в дополнительных заданиях.

##### Базовая часть

Шаблонный класс `UnorderedSet` должен быть параметризован типом ключа `KeyT`. Стратегия расширения такая же как в задаче
`String` - при добавлении элемента в пустую таблицу число корзин становится равным 1, при добавлении элемента в полную
таблицу число корзин увеличивается в 2 раза (таблица считается полной, если число корзин совпадает с числом элементов,
то есть `load_factor` == 1). В качестве хеш-функции воспользуйтесь `std::hash`. `std::hash` отображает объекты в
диапазон `size_t`, чтобы получить индекс корзины, возьмите остаток от деления полученного числа на количество корзин.

Набор методов включает:
* Конструктор по умолчанию. Создает пустую хеш-таблицу.
* Конструктор от числа корзин `count`. Создает хеш-таблицу с `count` пустыми корзинами.
* Конструктор от промежутка заданного двумя Forward итераторами. Создает хеш-таблицу с числом корзин равным числу
  элементов в последовательности, а затем вставляет элементы в таблицу.
* Конструкторы копирования, перемещения, а также присваивания должны работать корректно.
* Методы `Size`, `Empty`, `Clear` с привычной семантикой.
* Методы вставки `Insert(const KeyT&)`, `Insert(KeyT&&)`.
* Метод удаления `Erase(const KeyT&)`.
* Метод поиска `bool Find(const KeyT&)`.
* Метод `Rehash(new_bucket_count)`. Изменяет число корзин в хеш-таблице с перехешированием. Если `new_bucket_count`
  совпадает с текущим количеством корзин или меньше числа элементов (`load_factor` становится больше 1), то ничего
  делать не нужно.
* Метод `Reserve(new_bucket_count)`. То же, что и `Rehash`, но не уменьшает число корзин, то есть срабатывает, если
  `new_bucket_count` превышает текущее количество корзин.
* Методы `BucketCount` (возвращает число корзин в таблице), `BucketSize(id)` (возвращает размер корзины с номером `id`),
  `Bucket(key)` (возвращает номер корзины, в которую попадает объект `key`), `LoadFactor()` (возвращает степень
  заполненности таблицы).
  
Обратите внимание, что каждый раз создавать новые узлы списков при перехешировании может быть неэффективно. Для
переиспользования старых узлов (перебрасывания указателей старых списков) рассмотрите возможность использования метода
[std::list\<T\>::splice](https://en.cppreference.com/w/cpp/container/list/splice).

##### Дополнительное задание: итерирование

Этот пункт предполагает реализацию поддержки итераторов для `UnorderedSet`:
* Определение типов-членов `Iterator`, `ConstIterator`, `DifferenceType`.
* Определение методов `begin()`, `end()`, `cbegin()`, `cend()`. 
Если выполнено данное задание, добавьте строку `#define ITERATOR_IMPLEMENTED` в произвольном месте решения.

Кажется, что нет никаких проблем пройтись по элементам списка и, допустим, вывести их в консоль, или даже написать
итератор для класса `UnorderedSet`. Однако реализация итерирования может быть осложнена тем, что элементы расположены в
разных контейнерах, поэтому логика операции `++` нетривиальная. К тому же, проход по всем элементам таблицы займет
`O(n_buckets + n_elements)` времени (необходимо пройтись по всем корзинам и, если корзина не пуста, пройтись по ее
элементам), что очень неэффективно при `n_buckets` >> `n_elements`. Хочется добиться линейного от числа элементов
обхода, не зависящего от числа корзин (`O(n_elements)`).

Для решения этих проблем используется следующий подход: элементы хранятся в общем списке, при этом элементы
принадлежащие одной корзине лежат последовательно друг за другом. В корзине теперь хранится не список элементов, а
итератор на первый элемент списка, принадлежащей ей. Если корзина пуста, то хранится пустой итератор (сконструированный
по умолчанию).

*Пример:*
```
Пусть хеш таблица устроена следующим образом - [ [0, 1, 2], [], [3, 4], [], [5] ], то есть в корзине 0 расположены
элементы [0, 1, 2], корзина 1 пуста и т.д. Тогда корректный список элементов выглядит, например, так:
[3]<->[4]<->[0]<->[1]<->[2]<->[5]. Массив корзин же выглядит так: 
[ Iterator[0], Iterator[], Iterator[3], Iterator[], Iterator[5]], где Iterator[] - пустой итератор, а Iterator[i] -
итератор, указывающий на элемент со значением i.
```

Поиск осуществляется линейным проходом от начала корзины до первого элемента не лежащего в ней (это можно определить по
хеш-значению), либо до конца списка, если такого встречено не было. Вставка и удаление осуществляется с помощью методов
`insert` и `erase` для списка по итератору, указанному в корзине, либо с помощью `push_front`, если корзина пуста. При
этом важно аккуратно обновлять итераторы в корзинах при необходимости.

*Пример:*
```
Вернемся к примеру: элементы [3]<->[4]<->[0]<->[1]<->[2]<->[5], корзины
[ Iterator[0], Iterator[], Iterator[3], Iterator[], Iterator[5] ]. 
Вставим элемент 6 в корзину 0. Для этого вставим его в список перед элементом [0] и обновим итератор на начало:
[3]<->[4]<->[6]<->[0]<->[1]<->[2]<->[5], [ Iterator[6], Iterator[], Iterator[3], Iterator[], Iterator[5] ]
Удаление 3 состоит в удалении [3] из списка и обновлении итератора 2й корзины на [4].
При удалении 5 итератор 4й корзины становится пустым (корзина опустела).
[4]<->[6]<->[0]<->[1]<->[2], [ Iterator[6], Iterator[], Iterator[4], Iterator[], Iterator[] ]
```

Итерирование по хеш таблице при такой реализации эквивалентно итерированию по списку элементов.

*Полезный факт: при перемещении списка или вызова метода `swap` итераторы на элементы списка не инвалидируются.*

##### Дополнительное задание: односвязный список

Если выполнено данное задание, добавьте строку `#define FORWARD_LIST_IMPLEMENTED` в произвольном месте решения.

Правда ли, что нам нужен полный функционал двусвязного списка (`std::list`) для корректной реализации хеш-таблицы? При
поиске мы проходимся по элементам корзины в одном направлении 1 раз, аналогично при вставке и удалении. Обход
хеш-таблице так же требует лишь возможности прямого прохода (то есть категории ForwardIterator). Таким образом,
оказывается, что список элементов достаточно хранить в односвязном списке (`std::forward_list`). А если нет разницы, то
зачем платить больше (лишние расходы на хранение и поддержку обратных ссылок)?

Казалось бы, `ctrl+f` `std::list` + замена `std::list -> std::forward_list` = халявные баллы. Однако не все так просто.
Дело в том, что для удаления из односвязного списка недостаточно иметь итератор на элемент, так как он не хранит
ссылки на предыдущий и восстановить связность списка не представляется возможным. Поэтому для удаления необходим
итератор на элемент *предшествующий* удаляемому. Аналогичные проблемы возникают при выполнении операций `insert` и
`splice`. В связи с этим интерфейс `std::forward_list` отличается от интерфейса `std::list` наличием методов
`insert_after`, `erase_after`, `splice_after`.

Хорошо, а как удалить первый элемент списка? Или вставить элемент в начало списка? Для этого в `std::forward_list`
используется специальный итератор `before_begin()`, который указывает на фиктивную вершину в списке, расположенную
непосредственно перед нулевым элементом списка.

В связи с указанным выше, в корзинах должны храниться не итераторы на начала корзин, а итераторы на элементы, стоящие
перед ними.

*Пример:*
```
Хеш-таблица [ [0, 1, 2], [], [3, 4], [], [5] ] теперь представляется односвязным списком
[x]->[3]->[4]->[0]->[1]->[2]->[5], где [x] - фиктивный элемент перед началом списка (before_begin). 
В корзинах хранятся итераторы: [ Iterator[4], Iterator[], Iterator[x], Iterator[], Iterator[2] ]
```

При вставке и удалении нужно быть внимательным и аккуратно переприсваивать итераторы, так как какая-то из корзин могла
ссылаться на удаляемый элемент.

*Пример:*
```
[x]->[3]->[4]->[0]->[1]->[2]->[5],  [ Iterator[4], Iterator[], Iterator[x], Iterator[], Iterator[2] ]

Удалим элемент [2]. Несмотря на то, что [2] принадлежит нулевой корзине, его удаление испортит корзину номер 4 (она
ссылается на него, так как он предшествует элементу [5], лежащему в этой корзине). Поэтому необходимо сначала перенести
итератор 4й корзины на элемент [1] (элемент перед [2]) и только потом удалять [2]:
[x]->[3]->[4]->[0]->[1]->[5],  [ Iterator[4], Iterator[], Iterator[x], Iterator[], Iterator[1] ]
```

*Полезный факт: при перемещении односвязного списка или вызова метода `swap` итераторы на элементы списка не
инвалидируются. НО: итератор на элемент before_begin может стать невалидным.*

**Замечания.**
1. Решение должно состоять из одного файла `unordered_set.h`
